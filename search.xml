<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SpringBoot集成Memcached]]></title>
    <url>%2F2018%2F08%2F29%2FSpringBoot%E9%9B%86%E6%88%90Memcached%2F</url>
    <content type="text"><![CDATA[Docker安装Memcached 12docker pull Memcacheddocker run -name myMemcached -d -p 11211:11211 docker.io/memcached pom坐标 12345 &lt;dependency&gt; &lt;groupId&gt;com.whalin&lt;/groupId&gt; &lt;artifactId&gt;Memcached-Java-Client&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt;&lt;/dependency&gt; application.properties 123456789#缓存机制配置memcache.servers=192.168.0.197:11211memcache.weights=5memcache.initConn=20memcache.minConn=10memcache.maxConn=50memcache.maintSleep=3000memcache.nagle=falsememcache.socketTO=3000 配置SockIOPoolConfig 1234567891011121314151617181920@Data@Component@ConfigurationProperties(prefix = &quot;memcache&quot;)public class SockIOPoolConfig &#123; private String[] servers; private Integer[] weights; private int initConn; private int minConn; private int maxConn; private long maintSleep; private boolean nagle; private int socketTO;&#125; 配置MemcacheConfig，连接Memcached服务器 12345678910111213141516171819202122232425262728293031323334@Componentpublic class MemcacheConfig &#123; @Autowired SockIOPoolConfig sockIOPoolConfig; @Bean public SockIOPool sockIOPool()&#123; //获取连接池的实例 SockIOPool pool = SockIOPool.getInstance(); //服务器列表及其权重 String[] servers = sockIOPoolConfig.getServers(); Integer[] weights = sockIOPoolConfig.getWeights(); //设置服务器信息 pool.setServers(servers); pool.setWeights(weights); //设置初始连接数、最小连接数、最大连接数、最大处理时间 pool.setInitConn(sockIOPoolConfig.getInitConn()); pool.setMinConn(sockIOPoolConfig.getMinConn()); pool.setMaxConn(sockIOPoolConfig.getMaxConn()); //设置连接池守护线程的睡眠时间 pool.setMaintSleep(sockIOPoolConfig.getMaintSleep()); //设置TCP参数，连接超时 pool.setNagle(sockIOPoolConfig.isNagle()); pool.setSocketConnectTO(sockIOPoolConfig.getSocketTO()); //初始化并启动连接池 pool.initialize(); return pool; &#125; @Bean public MemCachedClient memCachedClient()&#123; return new MemCachedClient(); &#125;&#125; 测试 123456789101112131415 @AutowiredMemCachedClient memCachedClient;@Testpublic void contextLoads() &#123; boolean i = memCachedClient.set(&quot;id&quot;, &quot;123456&quot;, 1000); System.out.println(String.valueOf(i)); System.out.println(memCachedClient.get(&quot;id&quot;)); memCachedClient.replace(&quot;id&quot;,&quot;123&quot;); memCachedClient.replace(&quot;ok&quot;,&quot;123&quot;); System.out.println(memCachedClient.get(&quot;id&quot;)); memCachedClient.delete(&quot;id&quot;); System.out.println(memCachedClient.get(&quot;id&quot;)); System.out.println(memCachedClient.get(&quot;ok&quot;));&#125;]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot 集成 ElasticSearch6.3.2]]></title>
    <url>%2F2018%2F08%2F29%2FSpringBoot-%E9%9B%86%E6%88%90-ElasticSearch6-3-2%2F</url>
    <content type="text"><![CDATA[SpringBoot 集成 ElasticSearch的maven坐标 1234567891011121314151617 &lt;dependency&gt; &lt;groupId&gt;org.elasticsearch&lt;/groupId&gt; &lt;artifactId&gt;elasticsearch&lt;/artifactId&gt; &lt;version&gt;6.3.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt; &lt;artifactId&gt;transport&lt;/artifactId&gt; &lt;version&gt;6.3.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt; &lt;artifactId&gt;elasticsearch-rest-high-level-client&lt;/artifactId&gt; &lt;version&gt;6.3.2&lt;/version&gt;&lt;/dependency&gt; 配置application.properties 12345678#elk集群地址elasticsearch.ip=192.168.0.197#端口elasticsearch.port=9300#集群名称elasticsearch.cluster.name=my-es#连接池elasticsearch.pool=5 配置ElasticSearch源 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@Configurationpublic class ESconfig &#123; private static final Logger LOGGER = LoggerFactory.getLogger(ESconfig.class); /** * elk集群地址 */ @Value(&quot;$&#123;elasticsearch.ip&#125;&quot;) private String hostName; /** * 端口 */ @Value(&quot;$&#123;elasticsearch.port&#125;&quot;) private String port; /** * 集群名称 */ @Value(&quot;$&#123;elasticsearch.cluster.name&#125;&quot;) private String clusterName; /** * 连接池 */ @Value(&quot;$&#123;elasticsearch.pool&#125;&quot;) private String poolSize; @Bean public TransportClient init() &#123; LOGGER.info(&quot;初始化开始。。。。。&quot;); TransportClient transportClient = null; try &#123; // 配置信息 Settings esSetting = Settings.builder() .put(&quot;client.transport.sniff&quot;, true)//增加嗅探机制，找到ES集群 .put(&quot;thread_pool.search.size&quot;, Integer.parseInt(poolSize))//增加线程池个数，暂时设为5 .put(&quot;cluster.name&quot;,clusterName) .build(); //配置信息Settings自定义,下面设置为EMPTY transportClient = new PreBuiltTransportClient(esSetting); TransportAddress transportAddress = new TransportAddress(InetAddress.getByName(hostName), Integer.valueOf(port)); transportClient.addTransportAddresses(transportAddress); &#125; catch (Exception e) &#123; LOGGER.error(&quot;elasticsearch TransportClient create error!!!&quot;, e); &#125; return transportClient; &#125;&#125; 测试 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182/** * * 功能描述: 增加数据 * */ @PostMapping(&quot;person/add&quot;) public ResponseEntity add(@RequestBody Person person) &#123; try &#123; XContentBuilder content = XContentFactory.jsonBuilder().startObject() .field(&quot;name&quot;, person.getName()) .field(&quot;age&quot;, person.getAge()) .field(&quot;work&quot;, person.getWork()) .endObject(); String id = String.valueOf(person.getId()); IndexResponse result = this.client.prepareIndex(&quot;data&quot;, &quot;person&quot;,id).setSource(content).get(); return new ResponseEntity(result.getId(), HttpStatus.OK); &#125; catch (IOException e) &#123; e.printStackTrace(); return new ResponseEntity(HttpStatus.INTERNAL_SERVER_ERROR); &#125; &#125; /** * 功能描述: 查找数据 * */ @GetMapping(&quot;person/get&quot;) public ResponseEntity get(@RequestParam(name = &quot;id&quot;, defaultValue=&quot;&quot;) String id) &#123; if (id.isEmpty())&#123; return new ResponseEntity(HttpStatus.NOT_FOUND); &#125; GetResponse result = client.prepareGet(&quot;data&quot;, &quot;person&quot;, id).get(); if (!result.isExists()) &#123; return new ResponseEntity(HttpStatus.NOT_FOUND); &#125; return new ResponseEntity(result.getSource(), HttpStatus.OK); &#125; /** * * 功能描述: 更新数据 * */ @PutMapping(&quot;person/update&quot;) public ResponseEntity update(@RequestBody Person person)&#123; try &#123; XContentBuilder builder = XContentFactory.jsonBuilder().startObject(); if (person.getName()!= null) &#123; builder.field(&quot;name&quot;, person.getName()); &#125; if (person.getAge() != null) &#123; builder.field(&quot;age&quot;, person.getAge()); &#125; if(person.getWork() != null)&#123; builder.field(&quot;work&quot;, person.getWork()); &#125; builder.endObject(); String id = String.valueOf(person.getId()); UpdateRequest updateRequest = new UpdateRequest(&quot;data&quot;, &quot;person&quot;, id); updateRequest.doc(builder); UpdateResponse result = client.update(updateRequest).get(); return new ResponseEntity(result.getResult().toString(), HttpStatus.OK); &#125; catch (Exception e) &#123; e.printStackTrace(); return new ResponseEntity(HttpStatus.INTERNAL_SERVER_ERROR); &#125; &#125; /** * * 功能描述: 删除数据 * */ @DeleteMapping(&quot;person/delete&quot;) public ResponseEntity delete(@RequestParam(name = &quot;id&quot;) String id) &#123; DeleteResponse result = client.prepareDelete(&quot;data&quot;, &quot;person&quot;, id).get(); return new ResponseEntity(result.getResult().toString(), HttpStatus.OK); &#125;]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Elasticsearch6.3.2及其head插件安装]]></title>
    <url>%2F2018%2F08%2F29%2FElasticsearch6-3-2%E5%8F%8A%E5%85%B6head%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[下载并解压Elasticsearch6.3.2 进入config文件夹修改elasticsearch.yml文件 1234567891011121314151617# 集群的名字 cluster.name: my-es# 节点名字 node.name: node-1 # 数据存储目录（多个路径用逗号分隔） path.data: /home/els/es/data# 日志目录 path.logs: /home/els/es/log #本机的ip地址network.host: 192.168.0.197 # 设置节点间交互的tcp端口（集群）,(默认9300) transport.tcp.port: 9300 # 监听端口（默认） http.port: 9200 # 增加参数，使head插件可以访问es http.cors.enabled: true http.cors.allow-origin: &quot;*&quot; 进入bin文件夹启动es ./elasticsearch 下载载并解压head插件 修改_site文件夹中的app.js 1this.base_uri = this.config.base_uri || this.prefs.get(&quot;app-base_uri&quot;) || &quot;http://192.168.0.197:9200&quot;; 安装npm 1yum install git npm 安装grunt 1npm install -g grunt-cli 启动head 1grunt server]]></content>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo github搭建博客常用的命令]]></title>
    <url>%2F2018%2F08%2F29%2Fhexo-github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%B8%B8%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[常用命令 npm install hexo -g #安装 npm update hexo -g #升级 hexo init #初始化 hexo new “postName” #新建文章 hexo new page “pageName” #新建页面 hexo generate #生成静态页面至public目录 hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server） hexo deploy #将.deploy目录部署到GitHub hexo n #写文章 hexo g #生成 hexo d #部署 #可与hexo g合并为hexo d -g 一般操作，在博客目录下调出cmd命令窗口：1hexo new post &quot;xx&quot; 在E:\Blog\source_posts下，找到xx.md 用markdown编辑，完成后，先开启本地测试hexo s]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx负载均衡详解]]></title>
    <url>%2F2018%2F08%2F28%2FNginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[常见的负载均衡 热备：如果你有2台服务器，当一台服务器发生事故时，才启用第二台服务器给提供服务。服务器处理请求的顺序：AAAAAA突然A挂啦，BBBBBBBBBBBBBB….. 1234upstream mysvr &#123; server 127.0.0.1:7878; server 192.168.10.121:3333 backup; #热备 &#125; 轮询：nginx默认就是轮询其权重都默认为1，服务器处理请求的顺序：ABABABABAB…. 1234upstream mysvr &#123; server 127.0.0.1:7878; server 192.168.10.121:3333; &#125; 加权轮询：跟据配置的权重的大小而分发给不同服务器不同数量的请求。如果不设置，则默认为1。下面服务器的请求顺序为：ABBABBABBABBABB…. 1234 upstream mysvr &#123; server 127.0.0.1:7878 weight=1; server 192.168.10.121:3333 weight=2;&#125; ip_hash:nginx会让相同的客户端ip请求相同的服务器。 12345upstream mysvr &#123; server 127.0.0.1:7878; server 192.168.10.121:3333; ip_hash; &#125; 关于nginx负载均衡配置的几个状态参数讲解 down，表示当前的server暂时不参与负载均衡。 backup，预留的备份机器。当其他所有的非backup机器出现故障或者忙的时候，才会请求backup机器，因此这台机器的压力最轻。 max_fails，允许请求失败的次数，默认为1。当超过最大次数时，返回proxy_next_upstream 模块定义的错误。 fail_timeout，在经历了max_fails次失败后，暂停服务的时间。max_fails可以和fail_timeout一起使用。 1234upstream mysvr &#123; server 127.0.0.1:7878 weight=2 max_fails=2 fail_timeout=2; server 192.168.10.121:3333 weight=1 max_fails=2 fail_timeout=1; &#125;]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot2.X新特性]]></title>
    <url>%2F2018%2F08%2F28%2FSpringBoot2-X%E6%96%B0%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[基于 Java 8，支持 Java 9，这意味着不可以使用JDK7 或更旧的版本运行SpringBoot2. 支持 Quartz 调度程序 大大简化了安全自动配置 支持嵌入式 Netty Tomcat, Undertow 和 Jetty 均已支持 HTTP/2 全新的执行器架构，支持 Spring MVC, WebFlux 和 Jersey 使用 Spring WebFlux/WebFlux.fn 提供响应式 Web 编程支持 为各种组件的响应式编程提供了自动化配置，如：Reactive Spring Data、Reactive Spring Security 等 用于响应式 Spring Data Cassandra, MongoDB, Couchbase 和 Redis 的自动化配置和启动器 POM 引入对 Kotlin 1.2.x 的支持，并提供了一个 runApplication 函数，让你通过惯用的 Kotlin 来运行 Spring Boot 应用程序。更多信息请参阅参考文档中对 Kotlin 的支持部分 启动时的 ASCII 图像 Spring Boot banner 现已支持 GIF]]></content>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[My Blog]]></title>
    <url>%2F2018%2F08%2F28%2FMy-Blog%2F</url>
    <content type="text"><![CDATA[欢迎来到我的博客世界]]></content>
      <categories>
        <category>Welcome</category>
      </categories>
  </entry>
</search>
