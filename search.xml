<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SpringBoot集成Solr]]></title>
    <url>%2F2018%2F08%2F30%2FSpringBoot%E9%9B%86%E6%88%90Solr-1%2F</url>
    <content type="text"><![CDATA[添加springboot集成solr的依赖 1234 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-solr&lt;/artifactId&gt;&lt;/dependency&gt; application.yml指向solr地址 1234spring: data: solr: host: http://192.168.0.197:8983/solr/ik_core 添加solr实时更新操作 123456789101112131415161718192021222324252627282930313233343536373839404142@SpringBootApplication@EnableSchedulingpublic class SpringbootSolrApplication &#123; private Logger logger = LoggerFactory.getLogger(this.getClass()); @Autowired private RestTemplateBuilder builder; @Autowired private RestTemplate restTemplate; // 使用RestTemplateBuilder来实例化RestTemplate对象，spring默认已经注入了RestTemplateBuilder实例 @Bean public RestTemplate restTemplate() &#123; return builder.build(); &#125; public static void main(String[] args) &#123; SpringApplication.run(SpringbootSolrApplication.class, args); &#125; //每五秒执行一次 @Scheduled(cron = &quot;0/5 * * * * *&quot;) public void updateSolr() &#123; MultiValueMap&lt;String, Object&gt; postParameters = new LinkedMultiValueMap&lt;&gt;(); postParameters.add(&quot;command&quot;, &quot;full-import&quot;); postParameters.add(&quot;verbose&quot;, &quot;false&quot;); postParameters.add(&quot;clean&quot;, &quot;true&quot;); postParameters.add(&quot;commit&quot;, &quot;true&quot;); postParameters.add(&quot;core&quot;, &quot;ik_core&quot;); postParameters.add(&quot;name&quot;, &quot;dataimport&quot;); HttpHeaders headers = new HttpHeaders(); headers.add(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;); HttpEntity &lt;MultiValueMap &lt;String, Object&gt;&gt; r = new HttpEntity&lt;&gt;(postParameters, headers); String time = String.valueOf(new Date().getTime()); String url = &quot;http://192.168.0.197:8983/solr/ik_core/dataimport?_=&quot; + time + &quot;&amp;indent=on&amp;wt=json&quot;; String responseMessage = restTemplate.postForObject(url, r, String.class); logger.info(&quot;更新solr索引：返回值：&#123;&#125;&quot;, responseMessage); &#125;&#125; 测试查询（增加了高亮显示） 123456789101112131415161718192021222324252627282930313233343536373839404142@Test public void test() throws IOException, SolrServerException &#123; SolrQuery solrQuery = new SolrQuery(); solrQuery.set(&quot;q&quot;, &quot;title:*&quot;); solrQuery.set(&quot;start&quot;, 0); solrQuery.set(&quot;rows&quot;, 20); //======高亮设置=== //开启高亮 solrQuery.setHighlight(true); //高亮域 solrQuery.addHighlightField(&quot;title&quot;); //前缀 solrQuery.setHighlightSimplePre(&quot;&lt;span style=&apos;color:red&apos;&gt;&quot;); //后缀 solrQuery.setHighlightSimplePost(&quot;&lt;/span&gt;&quot;); QueryResponse response = solrClient.query(solrQuery); SolrDocumentList results = response.getResults(); System.out.println(&quot;查询内容:&quot; + solrQuery); System.out.println(&quot;文档数量：&quot; + results.getNumFound()); System.out.println(&quot;查询花费时间:&quot; + response.getQTime()); //获取高亮信息 Map&lt;String, Map&lt;String, List&lt;String&gt;&gt;&gt; highlighting = response.getHighlighting(); for (SolrDocument solrDocument :results) &#123; System.out.println(solrDocument); System.out.println(solrDocument.getFieldValue(&quot;cover&quot;)); System.out.println(solrDocument.getFieldValue(&quot;service_area&quot;)); //输出高亮 Map&lt;String, List&lt;String&gt;&gt; map = highlighting.get(solrDocument.get(&quot;id&quot;)); List&lt;String&gt; list = map.get(&quot;title&quot;); if(list != null &amp;&amp; list.size() &gt; 0)&#123; System.out.println(list.get(0)); &#125; &#125; &#125;]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker+Solr+IK]]></title>
    <url>%2F2018%2F08%2F30%2FDocker-Solr-IK%2F</url>
    <content type="text"><![CDATA[docker安装solr 1docker pull solr 启动solr镜像 1docker run -d -p 8983:8983 --name mysolr solr 123451. run 运行容器2. -d 代表后台运行3. -p 容器端口和宿机端口映射4. --name 容器名称5. solr 镜像名称 新建core 1docker exec -it --user=solr mysolr bin/solr create_core -c ik_core 进入solr容器 1docker exec -it -u root mysolr /bin/bash 安装vim(编辑容器里的文件) 12apt-get updateapt-get install vim 安装rzsz(上传下载容器里的文件) 1apt-get install lrzsz 进入/opt/solr/server/solr-webapp/webapp/WEB-INF/lib添加jar包 1234ik-analyzer-7.4.0.jarmysql-connector-java-8.0.11.jarsolr-dataimporthandler-7.4.0.jarsolr-dataimporthandler-extras-7.4.0.jar 进入/opt/solr/server/solr/ik_core/conf，新建data-config.xml 1234567891011121314151617181920212223242526272829&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;dataConfig&gt; &lt;dataSource name=&quot;source1&quot; type=&quot;JdbcDataSource&quot; driver=&quot;com.mysql.jdbc.Driver&quot; url=&quot;jdbc:mysql://***.**.**.**:3306/*****&quot; user=&quot;***&quot; password=&quot;*****&quot; batchSize=&quot;-1&quot; /&gt; &lt;document&gt; &lt;entity name=&quot;service_info&quot; dataSource=&quot;source1&quot; query=&quot;SELECT id,title,business_type_id,category_id , service_price , service_time,service_desc,service_area, cover,click_count,create_by,create_date,del_flag FROM service_info where del_flag = 1&quot;&gt; &lt;field column=&apos;id&apos; name=&apos;id&apos; /&gt; &lt;field column=&apos;title&apos; name=&apos;title&apos; /&gt; &lt;field column=&apos;business_type_id&apos; name=&apos;business_type_id&apos; /&gt; &lt;field column=&apos;category_id&apos; name=&apos;category_id&apos; /&gt; &lt;field column=&apos;service_price&apos; name=&apos;service_price&apos; /&gt; &lt;field column=&apos;service_time&apos; name=&apos;service_time&apos; /&gt; &lt;field column=&apos;service_desc&apos; name=&apos;service_desc&apos; /&gt; &lt;field column=&apos;service_area&apos; name=&apos;service_area&apos; /&gt; &lt;field column=&apos;cover&apos; name=&apos;cover&apos; /&gt; &lt;field column=&apos;click_count&apos; name=&apos;click_count&apos; /&gt; &lt;field column=&apos;create_by&apos; name=&apos;create_by&apos; /&gt; &lt;field column=&apos;create_date&apos; name=&apos;create_date&apos; /&gt; &lt;field column=&apos;del_flag&apos; name=&apos;del_flag&apos; /&gt; &lt;/entity&gt; &lt;/document&gt;&lt;/dataConfig&gt; 配置managed-schema，加入IK分词 123456789101112131415161718192021 &lt;!-- ik分词器 --&gt;&lt;fieldType name=&quot;text_ik&quot; class=&quot;solr.TextField&quot;&gt; &lt;analyzer type=&quot;index&quot; useSmart=&quot;false&quot; class=&quot;org.wltea.analyzer.lucene.IKAnalyzer&quot; /&gt; &lt;analyzer type=&quot;query&quot; useSmart=&quot;true&quot; class=&quot;org.wltea.analyzer.lucene.IKAnalyzer&quot; /&gt;&lt;/fieldType&gt; &lt;field name=&apos;id&apos; type=&quot;string&quot; indexed=&quot;true&quot; stored=&quot;true&quot;/&gt;&lt;field name=&apos;title&apos; type=&quot;text_ik&quot; indexed=&quot;true&quot; stored=&quot;true&quot; omitNorms = &quot;false&quot; omitTermFreqAndPositions =&quot;false&quot;/&gt; &lt;field name=&apos;business_type_id&apos; type=&quot;string&quot; indexed=&quot;true&quot; stored=&quot;true&quot;/&gt; &lt;field name=&apos;category_id&apos; type=&quot;string&quot; indexed=&quot;true&quot; stored=&quot;true&quot;/&gt; &lt;field name=&apos;service_price&apos; type=&quot;string&quot; indexed=&quot;true&quot; stored=&quot;true&quot;/&gt; &lt;field name=&apos;service_time&apos; type=&quot;string&quot; indexed=&quot;true&quot; stored=&quot;true&quot;/&gt; &lt;field name=&apos;service_desc&apos; type=&quot;text_ik&quot; indexed=&quot;true&quot; stored=&quot;true&quot;/&gt; &lt;field name=&apos;service_area&apos; type=&quot;text_ik&quot; indexed=&quot;true&quot; stored=&quot;true&quot;/&gt;&lt;field name=&apos;cover&apos; type=&quot;string&quot; indexed=&quot;true&quot; stored=&quot;true&quot;/&gt;&lt;field name=&apos;click_count&apos; type=&quot;string&quot; indexed=&quot;true&quot; stored=&quot;true&quot;/&gt; &lt;field name=&apos;create_by&apos; type=&quot;string&quot; indexed=&quot;true&quot; stored=&quot;true&quot;/&gt; &lt;field name=&apos;create_date&apos; type=&quot;string&quot; indexed=&quot;true&quot; stored=&quot;true&quot;/&gt;&lt;field name=&apos;del_flag&apos; type=&quot;string&quot; indexed=&quot;true&quot; stored=&quot;true&quot;/&gt; 配置solrconfig.xml 12345&lt;requestHandler name=&quot;/dataimport&quot; class=&quot;org.apache.solr.handler.dataimport.DataImportHandler&quot;&gt; &lt;lst name=&quot;defaults&quot;&gt; &lt;str name=&quot;config&quot;&gt;data-config.xml&lt;/str&gt; &lt;/lst&gt;&lt;/requestHandler&gt; 重启solr容器 1docker restart 45b022b95c71]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Solr</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot集成Memcached]]></title>
    <url>%2F2018%2F08%2F29%2FSpringBoot%E9%9B%86%E6%88%90Memcached%2F</url>
    <content type="text"><![CDATA[Docker安装Memcached 12docker pull Memcacheddocker run -name myMemcached -d -p 11211:11211 docker.io/memcached pom坐标 12345 &lt;dependency&gt; &lt;groupId&gt;com.whalin&lt;/groupId&gt; &lt;artifactId&gt;Memcached-Java-Client&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt;&lt;/dependency&gt; application.properties 123456789#缓存机制配置memcache.servers=192.168.0.197:11211memcache.weights=5memcache.initConn=20memcache.minConn=10memcache.maxConn=50memcache.maintSleep=3000memcache.nagle=falsememcache.socketTO=3000 配置SockIOPoolConfig 1234567891011121314151617181920@Data@Component@ConfigurationProperties(prefix = &quot;memcache&quot;)public class SockIOPoolConfig &#123; private String[] servers; private Integer[] weights; private int initConn; private int minConn; private int maxConn; private long maintSleep; private boolean nagle; private int socketTO;&#125; 配置MemcacheConfig，连接Memcached服务器 12345678910111213141516171819202122232425262728293031323334@Componentpublic class MemcacheConfig &#123; @Autowired SockIOPoolConfig sockIOPoolConfig; @Bean public SockIOPool sockIOPool()&#123; //获取连接池的实例 SockIOPool pool = SockIOPool.getInstance(); //服务器列表及其权重 String[] servers = sockIOPoolConfig.getServers(); Integer[] weights = sockIOPoolConfig.getWeights(); //设置服务器信息 pool.setServers(servers); pool.setWeights(weights); //设置初始连接数、最小连接数、最大连接数、最大处理时间 pool.setInitConn(sockIOPoolConfig.getInitConn()); pool.setMinConn(sockIOPoolConfig.getMinConn()); pool.setMaxConn(sockIOPoolConfig.getMaxConn()); //设置连接池守护线程的睡眠时间 pool.setMaintSleep(sockIOPoolConfig.getMaintSleep()); //设置TCP参数，连接超时 pool.setNagle(sockIOPoolConfig.isNagle()); pool.setSocketConnectTO(sockIOPoolConfig.getSocketTO()); //初始化并启动连接池 pool.initialize(); return pool; &#125; @Bean public MemCachedClient memCachedClient()&#123; return new MemCachedClient(); &#125;&#125; 测试 123456789101112131415 @AutowiredMemCachedClient memCachedClient;@Testpublic void contextLoads() &#123; boolean i = memCachedClient.set(&quot;id&quot;, &quot;123456&quot;, 1000); System.out.println(String.valueOf(i)); System.out.println(memCachedClient.get(&quot;id&quot;)); memCachedClient.replace(&quot;id&quot;,&quot;123&quot;); memCachedClient.replace(&quot;ok&quot;,&quot;123&quot;); System.out.println(memCachedClient.get(&quot;id&quot;)); memCachedClient.delete(&quot;id&quot;); System.out.println(memCachedClient.get(&quot;id&quot;)); System.out.println(memCachedClient.get(&quot;ok&quot;));&#125;]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot 集成 ElasticSearch6.3.2]]></title>
    <url>%2F2018%2F08%2F29%2FSpringBoot-%E9%9B%86%E6%88%90-ElasticSearch6-3-2%2F</url>
    <content type="text"><![CDATA[SpringBoot 集成 ElasticSearch的maven坐标 1234567891011121314151617 &lt;dependency&gt; &lt;groupId&gt;org.elasticsearch&lt;/groupId&gt; &lt;artifactId&gt;elasticsearch&lt;/artifactId&gt; &lt;version&gt;6.3.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt; &lt;artifactId&gt;transport&lt;/artifactId&gt; &lt;version&gt;6.3.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt; &lt;artifactId&gt;elasticsearch-rest-high-level-client&lt;/artifactId&gt; &lt;version&gt;6.3.2&lt;/version&gt;&lt;/dependency&gt; 配置application.properties 12345678#elk集群地址elasticsearch.ip=192.168.0.197#端口elasticsearch.port=9300#集群名称elasticsearch.cluster.name=my-es#连接池elasticsearch.pool=5 配置ElasticSearch源 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@Configurationpublic class ESconfig &#123; private static final Logger LOGGER = LoggerFactory.getLogger(ESconfig.class); /** * elk集群地址 */ @Value(&quot;$&#123;elasticsearch.ip&#125;&quot;) private String hostName; /** * 端口 */ @Value(&quot;$&#123;elasticsearch.port&#125;&quot;) private String port; /** * 集群名称 */ @Value(&quot;$&#123;elasticsearch.cluster.name&#125;&quot;) private String clusterName; /** * 连接池 */ @Value(&quot;$&#123;elasticsearch.pool&#125;&quot;) private String poolSize; @Bean public TransportClient init() &#123; LOGGER.info(&quot;初始化开始。。。。。&quot;); TransportClient transportClient = null; try &#123; // 配置信息 Settings esSetting = Settings.builder() .put(&quot;client.transport.sniff&quot;, true)//增加嗅探机制，找到ES集群 .put(&quot;thread_pool.search.size&quot;, Integer.parseInt(poolSize))//增加线程池个数，暂时设为5 .put(&quot;cluster.name&quot;,clusterName) .build(); //配置信息Settings自定义,下面设置为EMPTY transportClient = new PreBuiltTransportClient(esSetting); TransportAddress transportAddress = new TransportAddress(InetAddress.getByName(hostName), Integer.valueOf(port)); transportClient.addTransportAddresses(transportAddress); &#125; catch (Exception e) &#123; LOGGER.error(&quot;elasticsearch TransportClient create error!!!&quot;, e); &#125; return transportClient; &#125;&#125; 测试 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182/** * * 功能描述: 增加数据 * */ @PostMapping(&quot;person/add&quot;) public ResponseEntity add(@RequestBody Person person) &#123; try &#123; XContentBuilder content = XContentFactory.jsonBuilder().startObject() .field(&quot;name&quot;, person.getName()) .field(&quot;age&quot;, person.getAge()) .field(&quot;work&quot;, person.getWork()) .endObject(); String id = String.valueOf(person.getId()); IndexResponse result = this.client.prepareIndex(&quot;data&quot;, &quot;person&quot;,id).setSource(content).get(); return new ResponseEntity(result.getId(), HttpStatus.OK); &#125; catch (IOException e) &#123; e.printStackTrace(); return new ResponseEntity(HttpStatus.INTERNAL_SERVER_ERROR); &#125; &#125; /** * 功能描述: 查找数据 * */ @GetMapping(&quot;person/get&quot;) public ResponseEntity get(@RequestParam(name = &quot;id&quot;, defaultValue=&quot;&quot;) String id) &#123; if (id.isEmpty())&#123; return new ResponseEntity(HttpStatus.NOT_FOUND); &#125; GetResponse result = client.prepareGet(&quot;data&quot;, &quot;person&quot;, id).get(); if (!result.isExists()) &#123; return new ResponseEntity(HttpStatus.NOT_FOUND); &#125; return new ResponseEntity(result.getSource(), HttpStatus.OK); &#125; /** * * 功能描述: 更新数据 * */ @PutMapping(&quot;person/update&quot;) public ResponseEntity update(@RequestBody Person person)&#123; try &#123; XContentBuilder builder = XContentFactory.jsonBuilder().startObject(); if (person.getName()!= null) &#123; builder.field(&quot;name&quot;, person.getName()); &#125; if (person.getAge() != null) &#123; builder.field(&quot;age&quot;, person.getAge()); &#125; if(person.getWork() != null)&#123; builder.field(&quot;work&quot;, person.getWork()); &#125; builder.endObject(); String id = String.valueOf(person.getId()); UpdateRequest updateRequest = new UpdateRequest(&quot;data&quot;, &quot;person&quot;, id); updateRequest.doc(builder); UpdateResponse result = client.update(updateRequest).get(); return new ResponseEntity(result.getResult().toString(), HttpStatus.OK); &#125; catch (Exception e) &#123; e.printStackTrace(); return new ResponseEntity(HttpStatus.INTERNAL_SERVER_ERROR); &#125; &#125; /** * * 功能描述: 删除数据 * */ @DeleteMapping(&quot;person/delete&quot;) public ResponseEntity delete(@RequestParam(name = &quot;id&quot;) String id) &#123; DeleteResponse result = client.prepareDelete(&quot;data&quot;, &quot;person&quot;, id).get(); return new ResponseEntity(result.getResult().toString(), HttpStatus.OK); &#125;]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Elasticsearch6.3.2及其head插件安装]]></title>
    <url>%2F2018%2F08%2F29%2FElasticsearch6-3-2%E5%8F%8A%E5%85%B6head%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[下载并解压Elasticsearch6.3.2 进入config文件夹修改elasticsearch.yml文件 1234567891011121314151617# 集群的名字 cluster.name: my-es# 节点名字 node.name: node-1 # 数据存储目录（多个路径用逗号分隔） path.data: /home/els/es/data# 日志目录 path.logs: /home/els/es/log #本机的ip地址network.host: 192.168.0.197 # 设置节点间交互的tcp端口（集群）,(默认9300) transport.tcp.port: 9300 # 监听端口（默认） http.port: 9200 # 增加参数，使head插件可以访问es http.cors.enabled: true http.cors.allow-origin: &quot;*&quot; 进入bin文件夹启动es ./elasticsearch 下载载并解压head插件 修改_site文件夹中的app.js 1this.base_uri = this.config.base_uri || this.prefs.get(&quot;app-base_uri&quot;) || &quot;http://192.168.0.197:9200&quot;; 安装npm 1yum install git npm 安装grunt 1npm install -g grunt-cli 启动head 1grunt server]]></content>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo github搭建博客常用的命令]]></title>
    <url>%2F2018%2F08%2F29%2Fhexo-github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%B8%B8%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[常用命令 npm install hexo -g #安装 npm update hexo -g #升级 hexo init #初始化 hexo new “postName” #新建文章 hexo new page “pageName” #新建页面 hexo generate #生成静态页面至public目录 hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server） hexo deploy #将.deploy目录部署到GitHub hexo n #写文章 hexo g #生成 hexo d #部署 #可与hexo g合并为hexo d -g 一般操作，在博客目录下调出cmd命令窗口：1hexo new post &quot;xx&quot; 在E:\Blog\source_posts下，找到xx.md 用markdown编辑，完成后，先开启本地测试hexo s]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx负载均衡详解]]></title>
    <url>%2F2018%2F08%2F28%2FNginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[常见的负载均衡 热备：如果你有2台服务器，当一台服务器发生事故时，才启用第二台服务器给提供服务。服务器处理请求的顺序：AAAAAA突然A挂啦，BBBBBBBBBBBBBB….. 1234upstream mysvr &#123; server 127.0.0.1:7878; server 192.168.10.121:3333 backup; #热备 &#125; 轮询：nginx默认就是轮询其权重都默认为1，服务器处理请求的顺序：ABABABABAB…. 1234upstream mysvr &#123; server 127.0.0.1:7878; server 192.168.10.121:3333; &#125; 加权轮询：跟据配置的权重的大小而分发给不同服务器不同数量的请求。如果不设置，则默认为1。下面服务器的请求顺序为：ABBABBABBABBABB…. 1234 upstream mysvr &#123; server 127.0.0.1:7878 weight=1; server 192.168.10.121:3333 weight=2;&#125; ip_hash:nginx会让相同的客户端ip请求相同的服务器。 12345upstream mysvr &#123; server 127.0.0.1:7878; server 192.168.10.121:3333; ip_hash; &#125; 关于nginx负载均衡配置的几个状态参数讲解 down，表示当前的server暂时不参与负载均衡。 backup，预留的备份机器。当其他所有的非backup机器出现故障或者忙的时候，才会请求backup机器，因此这台机器的压力最轻。 max_fails，允许请求失败的次数，默认为1。当超过最大次数时，返回proxy_next_upstream 模块定义的错误。 fail_timeout，在经历了max_fails次失败后，暂停服务的时间。max_fails可以和fail_timeout一起使用。 1234upstream mysvr &#123; server 127.0.0.1:7878 weight=2 max_fails=2 fail_timeout=2; server 192.168.10.121:3333 weight=1 max_fails=2 fail_timeout=1; &#125;]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot2.X新特性]]></title>
    <url>%2F2018%2F08%2F28%2FSpringBoot2-X%E6%96%B0%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[基于 Java 8，支持 Java 9，这意味着不可以使用JDK7 或更旧的版本运行SpringBoot2. 支持 Quartz 调度程序 大大简化了安全自动配置 支持嵌入式 Netty Tomcat, Undertow 和 Jetty 均已支持 HTTP/2 全新的执行器架构，支持 Spring MVC, WebFlux 和 Jersey 使用 Spring WebFlux/WebFlux.fn 提供响应式 Web 编程支持 为各种组件的响应式编程提供了自动化配置，如：Reactive Spring Data、Reactive Spring Security 等 用于响应式 Spring Data Cassandra, MongoDB, Couchbase 和 Redis 的自动化配置和启动器 POM 引入对 Kotlin 1.2.x 的支持，并提供了一个 runApplication 函数，让你通过惯用的 Kotlin 来运行 Spring Boot 应用程序。更多信息请参阅参考文档中对 Kotlin 的支持部分 启动时的 ASCII 图像 Spring Boot banner 现已支持 GIF]]></content>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[My Blog]]></title>
    <url>%2F2018%2F08%2F28%2FMy-Blog%2F</url>
    <content type="text"><![CDATA[欢迎来到我的博客世界]]></content>
      <categories>
        <category>Welcome</category>
      </categories>
  </entry>
</search>
